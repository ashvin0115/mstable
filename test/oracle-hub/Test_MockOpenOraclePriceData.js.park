const {balance, BN, constants, ether, expect, expectEvent, makeInterfaceId, send, should, shouldFail, time}
    = require('openzeppelin-test-helpers');

const MockOpenOraclePriceData = artifacts.require('MockOpenOraclePriceData');

contract('Testing MockOpenOraclePriceData', (accounts) => {

    //const INITIAL_SUPPLY = new BN('1000000000000000000000000');

    const deployer = accounts[0];
    const other = accounts[1];
    const other2 = accounts[2];

    var moopd;

    beforeEach('Reset MockOpenOraclePriceData', async function () {
        moopd = await MockOpenOraclePriceData.new({from: deployer});
    });

    describe('MockOpenOraclePriceData Defaults', function () {
        it('should get default values', async function () {
            const defaultBase =     1000000;
            const defaultVariance =   10000;
            const {0: time, 1: price} = await moopd.get(other, "this value does not matter");
            time.should.be.bignumber.gt(new BN(0));
            price.should.be.bignumber.gte(new BN(defaultBase - defaultVariance));
            price.should.be.bignumber.lte(new BN(defaultBase + defaultVariance));
        });
    });

    describe('MockOpenOraclePriceData Configuration', function () {
        it('should allow configuration', async function () {
            const testKey = "testKey";
            const base =        5500000;
            const variance =    0001000;
            const interval =         10;
            await moopd.configure(testKey, base, variance, interval);
            const {0: time, 1: price} = await moopd.get(other, testKey);
            time.should.be.bignumber.gt(new BN(0));
            price.should.be.bignumber.gte(new BN(base - variance));
            price.should.be.bignumber.lte(new BN(base + variance));
        });
    });

    /*
    describe('Burning', function () {
        it('should allow deployer to burn their own MTA', async function () {
            await meta.burn(INITIAL_SUPPLY.div(new BN('2')));
            (await meta.balanceOf(deployer)).should.be.bignumber.equal(INITIAL_SUPPLY.div(new BN('2')));
            (await meta.totalSupply()).should.be.bignumber.equal(INITIAL_SUPPLY.div(new BN('2')));
        });
        it('should not allow an address with no burner role to burn MTA', async function () {
            await meta.transfer(other, '1', {from: deployer});
            await shouldFail.reverting(meta.burn('1', {from: other}));
        });
        it('should allow deployer to grant burner role to another address', async function () {
            const {logs} = await meta.addBurner(other, {from: deployer});
            expectEvent.inLogs(logs, 'BurnerAdded', {account: other});
        });
        it('should not allow address with no burner role to grant burner roles', async function () {
            await shouldFail.reverting(meta.addBurner(other2, {from: other}));
        });
        it('should allow deployer to allow another burner to burn deployer\'s MTA', async function () {
            await meta.approve(other, '1000000000000000000000000', {from: deployer});
            await meta.addBurner(other, {from: deployer});
            await meta.burnFrom(deployer, '1000000000000000000000000', {from: other});
            (await meta.balanceOf(deployer)).should.be.bignumber.equal(new BN('0'));
        });
    });

    describe('Setting', function () {
        it('should allow deployer to change the token name', async function () {
            await meta.setName('META');
            (await meta.name()).should.equal('META');
        });
        it('should allow deployer to change the token symbol', async function () {
            await meta.setSymbol('MSTABLE');
            (await meta.symbol()).should.equal('MSTABLE');
        });
    });
    */
});
