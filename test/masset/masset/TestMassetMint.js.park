const {balance, BN, constants, ether, expect, expectEvent, makeInterfaceId, send, should, shouldFail, time}
    = require('openzeppelin-test-helpers');

const MetaToken = artifacts.require("MetaToken");
const MetaPriceOracle = artifacts.require("MetaPriceOracle");
const MetaUSDToken = artifacts.require("MetaUSDToken");
const ERC20MockToken = artifacts.require("ERC20MockToken");

contract('Testing MetaUSDToken Minting', (accounts) => {

    const DECIMALS = 18;
    const MAX_WEIGHT = new BN('1000000000000000000');

    const accountOne = accounts[0];
    const accountTwo = accounts[1];

    let musd, meta, metaOracle;
    let token1, token2, token3, token4, token5;

    let weight1 = MAX_WEIGHT.div(new BN(100)).mul(new BN(50)); //50%
    let weight2 = MAX_WEIGHT.div(new BN(100)).mul(new BN(40)); //40%
    let weight3 = MAX_WEIGHT.div(new BN(100)).mul(new BN(9)); //9%
    let weight4 = MAX_WEIGHT.div(new BN(10000)).mul(new BN(99)); //0.99%
    let weight5 = MAX_WEIGHT.div(new BN(10000)).mul(new BN(1)); //0.01%

    before('Initialize all ERC20 tokens and mUSD setup before beginning tests', async function () {

        meta = await MetaToken.new({from: accountOne});
        metaOracle = await MetaPriceOracle.new({from: accountOne});
        musd = await MetaUSDToken.new({from: accountOne});
        token1 = await ERC20MockToken.new("token1", "ONE", 0, 1000000, {from: accountOne}); //total supply = 1mil wei
        token2 = await ERC20MockToken.new("token2", "TWO", 1, 1000000, {from: accountOne}); //total supply = 10mil wei
        token3 = await ERC20MockToken.new("token3", "THREE", 4, 1000000, {from: accountOne}); //total supply = 10bil wei
        token4 = await ERC20MockToken.new("token4", "FOUR", 8, 2500000, {from: accountOne}); //total supply = 250tril wei
        token5 = await ERC20MockToken.new("token5", "FIVE", 18, 1234567890, {from: accountOne}); //total supply = 1.23456789tril * 10^18 wei

        //allow mUSD contract to burn MTA
        await meta.addBurner(musd.address);
        (await meta.isBurner(musd.address)).should.be.true;

        await musd.addToBasket(token1.address, weight1);
        await musd.addToBasket(token2.address, weight2);
        await musd.addToBasket(token3.address, weight3);
        await musd.addToBasket(token4.address, weight4);
        await musd.addToBasket(token5.address, weight5);

        await musd.setMetaTokenContract(meta.address);
        await musd.setMetaPriceOracleContract(metaOracle.address);

        await musd.endSetupPhase();

    });

    describe('Test depositTokensThenMint function', function () {
        it('should not allow valid deposit of tokens then invalid minting', async function () {

            //do valid (but bare minimum) deposits
            let qty1 = new BN(1);
            let qty2 = new BN(1);
            let qty3 = new BN(1);
            let qty4 = new BN(1);
            let qty5 = new BN(1);

            //do approvals
            await token1.approve(musd.address, qty1);
            await token2.approve(musd.address, qty2);
            await token3.approve(musd.address, qty3);
            await token4.approve(musd.address, qty4);
            await token5.approve(musd.address, qty5);

            tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            quantities = [qty1, qty2, qty3, qty4, qty5];

            let mintQty = new BN(9999); //$9999 in mUSD (will have insufficient balances)

            //scale mintQty with decimal places
            mintQty = mintQty.mul(
                new BN(10).pow(await musd.decimals())
            );

            await shouldFail.reverting(musd.depositTokensThenMint(tokenAddresses, quantities, mintQty));

        });
        it('should not allow invalid deposit of tokens then minting', async function () {

            //do invalid deposits (cannot deposit 0)
            let qty1 = new BN(1);
            let qty2 = new BN(1);
            let qty3 = new BN(0);
            let qty4 = new BN(1);
            let qty5 = new BN(1);

            //do approvals
            await token1.approve(musd.address, qty1);
            await token2.approve(musd.address, qty2);
            await token3.approve(musd.address, qty3);
            await token4.approve(musd.address, qty4);
            await token5.approve(musd.address, qty5);

            tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            quantities = [qty1, qty2, qty3, qty4, qty5];

            let mintQty = new BN(10); //$10 in mUSD

            //scale mintQty with decimal places
            mintQty = mintQty.mul(
                new BN(10).pow(await musd.decimals())
            );

            await shouldFail.reverting(musd.depositTokensThenMint(tokenAddresses, quantities, mintQty));

        });
        it('should allow valid deposit of tokens then valid minting', async function () {

            let mintQty = new BN(9999); //$9999 in mUSD

            let qty1 = (mintQty
                .mul(new BN(10).pow(await token1.decimals()))
                .mul(new BN(weight1)))
                .div(MAX_WEIGHT);
            let qty2 = (mintQty
                .mul(new BN(10).pow(await token2.decimals()))
                .mul(new BN(weight2)))
                .div(MAX_WEIGHT);
            let qty3 = (mintQty
                .mul(new BN(10).pow(await token3.decimals()))
                .mul(new BN(weight3)))
                .div(MAX_WEIGHT);
            let qty4 = (mintQty
                .mul(new BN(10).pow(await token4.decimals()))
                .mul(new BN(weight4)))
                .div(MAX_WEIGHT);
            let qty5 = (mintQty
                .mul(new BN(10).pow(await token5.decimals()))
                .mul(new BN(weight5)))
                .div(MAX_WEIGHT);

            await token1.approve(musd.address, qty1);
            await token2.approve(musd.address, qty2);
            await token3.approve(musd.address, qty3);
            await token4.approve(musd.address, qty4);
            await token5.approve(musd.address, qty5);

            tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            quantities = [qty1, qty2, qty3, qty4, qty5];

            //scale mintQty with decimal places
            mintQty = mintQty.mul(
                new BN(10).pow(await musd.decimals())
            );

            await musd.depositTokensThenMint(tokenAddresses, quantities, mintQty);

        });
        it('should correctly update (token, MTA, mUSD) balances after valid deposit of tokens followed by minting', async function () {

            let initialmUSDBalance = await musd.balanceOf(accountOne);
            let initialMetaBalance = await meta.balanceOf(accountOne);
            let initial1 = await musd.userTokenBalances(accountOne, token1.address);
            let initial2 = await musd.userTokenBalances(accountOne, token2.address);
            let initial3 = await musd.userTokenBalances(accountOne, token3.address);
            let initial4 = await musd.userTokenBalances(accountOne, token4.address);
            let initial5 = await musd.userTokenBalances(accountOne, token5.address);

            let mintQty = new BN(9999); //$9999 in mUSD

            let qty1 = (mintQty
                .mul(new BN(10).pow(await token1.decimals()))
                .mul(new BN(weight1)))
                .div(MAX_WEIGHT);
            let qty2 = (mintQty
                .mul(new BN(10).pow(await token2.decimals()))
                .mul(new BN(weight2)))
                .div(MAX_WEIGHT);
            let qty3 = (mintQty
                .mul(new BN(10).pow(await token3.decimals()))
                .mul(new BN(weight3)))
                .div(MAX_WEIGHT);
            let qty4 = (mintQty
                .mul(new BN(10).pow(await token4.decimals()))
                .mul(new BN(weight4)))
                .div(MAX_WEIGHT);
            let qty5 = (mintQty
                .mul(new BN(10).pow(await token5.decimals()))
                .mul(new BN(weight5)))
                .div(MAX_WEIGHT);

            await token1.approve(musd.address, qty1);
            await token2.approve(musd.address, qty2);
            await token3.approve(musd.address, qty3);
            await token4.approve(musd.address, qty4);
            await token5.approve(musd.address, qty5);

            tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            quantities = [qty1, qty2, qty3, qty4, qty5];

            //set minting fee
            const metaFee = new BN(2).mul(new BN(10).pow(new BN(16))); //2%
            await musd.setMintingFee(metaFee);

            //scale mintQty with decimal places
            mintQty = mintQty.mul(
                new BN(10).pow(await musd.decimals())
            );

            await musd.depositTokensThenMint(tokenAddresses, quantities, mintQty);

            //check mUSD balance
            (await musd.balanceOf(accountOne)).should.be.bignumber.equal(initialmUSDBalance.add(mintQty));

            //check token balances
            (await musd.userTokenBalances(accountOne, token1.address)).should.be.bignumber.equal(initial1);
            (await musd.userTokenBalances(accountOne, token2.address)).should.be.bignumber.equal(initial2);
            (await musd.userTokenBalances(accountOne, token3.address)).should.be.bignumber.equal(initial3);
            (await musd.userTokenBalances(accountOne, token4.address)).should.be.bignumber.equal(initial4);
            (await musd.userTokenBalances(accountOne, token5.address)).should.be.bignumber.equal(initial5);

            //then check MTA balance
            (await meta.balanceOf(accountOne)).should.be.bignumber.equal(
                initialMetaBalance.sub(
                    mintQty
                        .mul(metaFee)
                        .div(new BN(10).pow(await musd.decimals()))
                        .mul(new BN(100))
                        .div(await metaOracle.getPrice())
                )
            );
            
            //set minting fee back to zero
            await musd.setMintingFee(new BN(0));

        });
    });

    describe('Test mint function', function () {
        it('should not allow minting of a zero quantity', async function () {

            await shouldFail.reverting(musd.mint(new BN(0)));

        });
        it('should not allow minting with insufficient balance', async function () {

            await shouldFail.reverting(musd.mint(new BN(1000)));

        });
        it('should not allow minting if a weighted quantity rounds down to 0', async function () {

            let mintQty = new BN(1); //$1 in mUSD

            // basket quantities for 1 mUSD:
            // 0.5 standard units of token 1 = 0.5 * 10^(0 decimal places) = 0.5 units
            // 0.4 standard units of token 2 = 0.4 * 10^(1 decimal place) = 4 units
            // 0.09 standard units of token 3 = 0.09 * 10^(4 decimal places) = 900 units
            // 0.0099 standard units of token 4 = 0.0099 * 10^(8 decimal places) = 990000 units
            // 0.0001 standard units of token 5 = 0.0001 * 10^(18 decimal places) = 100000000000000 units

            //multiply by 10 so we deposit 5 units instead of 0.5 units for token1 (so the deposit works)
            let qty1 = (mintQty
                .mul(new BN(10))
                .mul(new BN(10).pow(await token1.decimals()))
                .mul(new BN(weight1)))
                .div(MAX_WEIGHT);
            let qty2 = (mintQty
                .mul(new BN(10).pow(await token2.decimals()))
                .mul(new BN(weight2)))
                .div(MAX_WEIGHT);
            let qty3 = (mintQty
                .mul(new BN(10).pow(await token3.decimals()))
                .mul(new BN(weight3)))
                .div(MAX_WEIGHT);
            let qty4 = (mintQty
                .mul(new BN(10).pow(await token4.decimals()))
                .mul(new BN(weight4)))
                .div(MAX_WEIGHT);
            let qty5 = (mintQty
                .mul(new BN(10).pow(await token5.decimals()))
                .mul(new BN(weight5)))
                .div(MAX_WEIGHT);

            //do approvals first
            await token1.approve(musd.address, qty1);
            await token2.approve(musd.address, qty2);
            await token3.approve(musd.address, qty3);
            await token4.approve(musd.address, qty4);
            await token5.approve(musd.address, qty5);

            //then deposit
            tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            quantities = [qty1, qty2, qty3, qty4, qty5];
            await musd.depositTokens(tokenAddresses, quantities);
            
            //scale mintQty with decimal places
            mintQty = mintQty.mul(
                new BN(10).pow(await musd.decimals())
            );

            //then mint (which should fail because weighted quantity of 0.5 for token1 rounds down to 0)
            await shouldFail.reverting(musd.mint(mintQty));

        });
        it('should allow valid minting', async function () {

            let mintQty = new BN(1234); //$1234 in mUSD

            let qty1 = (mintQty
                .mul(new BN(10).pow(await token1.decimals()))
                .mul(new BN(weight1)))
                .div(MAX_WEIGHT);
            let qty2 = (mintQty
                .mul(new BN(10).pow(await token2.decimals()))
                .mul(new BN(weight2)))
                .div(MAX_WEIGHT);
            let qty3 = (mintQty
                .mul(new BN(10).pow(await token3.decimals()))
                .mul(new BN(weight3)))
                .div(MAX_WEIGHT);
            let qty4 = (mintQty
                .mul(new BN(10).pow(await token4.decimals()))
                .mul(new BN(weight4)))
                .div(MAX_WEIGHT);
            let qty5 = (mintQty
                .mul(new BN(10).pow(await token5.decimals()))
                .mul(new BN(weight5)))
                .div(MAX_WEIGHT);

            //do approvals first
            await token1.approve(musd.address, qty1);
            await token2.approve(musd.address, qty2);
            await token3.approve(musd.address, qty3);
            await token4.approve(musd.address, qty4);
            await token5.approve(musd.address, qty5);

            //then deposit
            tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            quantities = [qty1, qty2, qty3, qty4, qty5];
            await musd.depositTokens(tokenAddresses, quantities);

            //scale mintQty with decimal places
            mintQty = mintQty.mul(
                new BN(10).pow(await musd.decimals())
            );

            //then mint
            await musd.mint(mintQty);

        });
        it('should correctly increase mUSD balance after valid minting', async function () {

            let initialBalance = await musd.balanceOf(accountOne);

            let mintQty = new BN(10); //$10 in mUSD
            let qty1 = (mintQty
                .mul(new BN(10).pow(await token1.decimals()))
                .mul(new BN(weight1)))
                .div(MAX_WEIGHT);
            let qty2 = (mintQty
                .mul(new BN(10).pow(await token2.decimals()))
                .mul(new BN(weight2)))
                .div(MAX_WEIGHT);
            let qty3 = (mintQty
                .mul(new BN(10).pow(await token3.decimals()))
                .mul(new BN(weight3)))
                .div(MAX_WEIGHT);
            let qty4 = (mintQty
                .mul(new BN(10).pow(await token4.decimals()))
                .mul(new BN(weight4)))
                .div(MAX_WEIGHT);
            let qty5 = (mintQty
                .mul(new BN(10).pow(await token5.decimals()))
                .mul(new BN(weight5)))
                .div(MAX_WEIGHT);

            //do approvals first
            await token1.approve(musd.address, qty1);
            await token2.approve(musd.address, qty2);
            await token3.approve(musd.address, qty3);
            await token4.approve(musd.address, qty4);
            await token5.approve(musd.address, qty5);

            //then deposit
            tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            quantities = [qty1, qty2, qty3, qty4, qty5];
            await musd.depositTokens(tokenAddresses, quantities);

            //scale mintQty with decimal places
            mintQty = mintQty.mul(
                new BN(10).pow(await musd.decimals())
            );

            //then mint
            await musd.mint(mintQty);

            //then check mUSD balance
            (await musd.balanceOf(accountOne)).should.be.bignumber.equal(initialBalance.add(mintQty));

        });
        it('should correctly update token balances after valid minting', async function () {

            let initial1 = await musd.userTokenBalances(accountOne, token1.address);
            let initial2 = await musd.userTokenBalances(accountOne, token2.address);
            let initial3 = await musd.userTokenBalances(accountOne, token3.address);
            let initial4 = await musd.userTokenBalances(accountOne, token4.address);
            let initial5 = await musd.userTokenBalances(accountOne, token5.address);

            let mintQty = new BN(10); //$10 in mUSD

            // basket quantities for 1 mUSD:
            // 0.5 standard units of token 1 = 0.5 * 10^(0 decimal places) = 0.5 units
            // 0.4 standard units of token 2 = 0.4 * 10^(1 decimal place) = 4 units
            // 0.09 standard units of token 3 = 0.09 * 10^(4 decimal places) = 900 units
            // 0.0099 standard units of token 4 = 0.0099 * 10^(8 decimal places) = 990000 units
            // 0.0001 standard units of token 5 = 0.0001 * 10^(18 decimal places) = 100000000000000 units
            let qty1 = (mintQty
                .mul(new BN(10).pow(await token1.decimals()))
                .mul(new BN(weight1)))
                .div(MAX_WEIGHT);
            let qty2 = (mintQty
                .mul(new BN(10).pow(await token2.decimals()))
                .mul(new BN(weight2)))
                .div(MAX_WEIGHT);
            let qty3 = (mintQty
                .mul(new BN(10).pow(await token3.decimals()))
                .mul(new BN(weight3)))
                .div(MAX_WEIGHT);
            let qty4 = (mintQty
                .mul(new BN(10).pow(await token4.decimals()))
                .mul(new BN(weight4)))
                .div(MAX_WEIGHT);
            let qty5 = (mintQty
                .mul(new BN(10).pow(await token5.decimals()))
                .mul(new BN(weight5)))
                .div(MAX_WEIGHT);

            //do approvals first
            await token1.approve(musd.address, qty1);
            await token2.approve(musd.address, qty2);
            await token3.approve(musd.address, qty3);
            await token4.approve(musd.address, qty4);
            await token5.approve(musd.address, qty5);

            //then deposit
            tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            quantities = [qty1, qty2, qty3, qty4, qty5];
            await musd.depositTokens(tokenAddresses, quantities);

            //scale mintQty with decimal places
            mintQty = mintQty.mul(
                new BN(10).pow(await musd.decimals())
            );

            //then mint
            await musd.mint(mintQty);

            //then check token balances
            (await musd.userTokenBalances(accountOne, token1.address)).should.be.bignumber.equal(initial1);
            (await musd.userTokenBalances(accountOne, token2.address)).should.be.bignumber.equal(initial2);
            (await musd.userTokenBalances(accountOne, token3.address)).should.be.bignumber.equal(initial3);
            (await musd.userTokenBalances(accountOne, token4.address)).should.be.bignumber.equal(initial4);
            (await musd.userTokenBalances(accountOne, token5.address)).should.be.bignumber.equal(initial5);

        });
        it('should correctly burn MTA balance after valid minting', async function () {

            let initialBalance = await meta.balanceOf(accountOne);

            let mintQty = new BN(10); //$10 in mUSD

            let qty1 = (mintQty
                .mul(new BN(10).pow(await token1.decimals()))
                .mul(new BN(weight1)))
                .div(MAX_WEIGHT);
            let qty2 = (mintQty
                .mul(new BN(10).pow(await token2.decimals()))
                .mul(new BN(weight2)))
                .div(MAX_WEIGHT);
            let qty3 = (mintQty
                .mul(new BN(10).pow(await token3.decimals()))
                .mul(new BN(weight3)))
                .div(MAX_WEIGHT);
            let qty4 = (mintQty
                .mul(new BN(10).pow(await token4.decimals()))
                .mul(new BN(weight4)))
                .div(MAX_WEIGHT);
            let qty5 = (mintQty
                .mul(new BN(10).pow(await token5.decimals()))
                .mul(new BN(weight5)))
                .div(MAX_WEIGHT);

            //do approvals first
            await token1.approve(musd.address, qty1);
            await token2.approve(musd.address, qty2);
            await token3.approve(musd.address, qty3);
            await token4.approve(musd.address, qty4);
            await token5.approve(musd.address, qty5);

            //then deposit
            tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            quantities = [qty1, qty2, qty3, qty4, qty5];
            await musd.depositTokens(tokenAddresses, quantities);

            //set minting fee
            const metaFee = new BN(2).mul(new BN(10).pow(new BN(16))); //2%
            await musd.setMintingFee(metaFee);

            //scale mintQty with decimal places
            mintQty = mintQty.mul(
                new BN(10).pow(await musd.decimals())
            );

            //then mint
            await musd.mint(mintQty);

            //then check MTA balance
            (await meta.balanceOf(accountOne)).should.be.bignumber.equal(
                initialBalance.sub(
                    mintQty
                        .mul(metaFee)
                        .div(new BN(10).pow(await musd.decimals()))
                        .mul(new BN(100))
                        .div(await metaOracle.getPrice())
                )
            );

            //set minting fee back to zero
            await musd.setMintingFee(new BN(0));

        });
    });

});
