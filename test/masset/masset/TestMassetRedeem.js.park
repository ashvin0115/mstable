const {balance, BN, constants, ether, expect, expectEvent, makeInterfaceId, send, should, shouldFail, time}
    = require('openzeppelin-test-helpers');

const MetaToken = artifacts.require("MetaToken");
const MetaPriceOracle = artifacts.require("MetaPriceOracle");
const MetaUSDToken = artifacts.require("MetaUSDToken");
const ERC20MockToken = artifacts.require("ERC20MockToken");

contract('Testing MetaUSDToken Redeem', (accounts) => {

    const DECIMALS = 18;
    const MAX_WEIGHT = new BN('1000000000000000000');

    const accountOne = accounts[0];
    const accountTwo = accounts[1];

    let musd, meta, metaOracle;
    let token1, token2, token3, token4, token5;

    let weight1 = MAX_WEIGHT.div(new BN(100)).mul(new BN(50)); //50%
    let weight2 = MAX_WEIGHT.div(new BN(100)).mul(new BN(40)); //40%
    let weight3 = MAX_WEIGHT.div(new BN(100)).mul(new BN(9)); //9%
    let weight4 = MAX_WEIGHT.div(new BN(10000)).mul(new BN(99)); //0.99%
    let weight5 = MAX_WEIGHT.div(new BN(10000)).mul(new BN(1)); //0.01%

    before('Initialize all ERC20 tokens and mUSD setup before beginning tests', async function () {

        meta = await MetaToken.new({from: accountOne});
        metaOracle = await MetaPriceOracle.new({from: accountOne});
        musd = await MetaUSDToken.new({from: accountOne});
        token1 = await ERC20MockToken.new("token1", "ONE", 0, 1000000, {from: accountOne}); //total supply = 1mil wei
        token2 = await ERC20MockToken.new("token2", "TWO", 1, 1000000, {from: accountOne}); //total supply = 10mil wei
        token3 = await ERC20MockToken.new("token3", "THREE", 4, 1000000, {from: accountOne}); //total supply = 10bil wei
        token4 = await ERC20MockToken.new("token4", "FOUR", 8, 2500000, {from: accountOne}); //total supply = 250tril wei
        token5 = await ERC20MockToken.new("token5", "FIVE", 18, 1234567890, {from: accountOne}); //total supply = 1.23456789tril * 10^18 wei

        //allow mUSD contract to burn MTA
        await meta.addBurner(musd.address);
        (await meta.isBurner(musd.address)).should.be.true;

        await musd.addToBasket(token1.address, weight1);
        await musd.addToBasket(token2.address, weight2);
        await musd.addToBasket(token3.address, weight3);
        await musd.addToBasket(token4.address, weight4);
        await musd.addToBasket(token5.address, weight5);

        await musd.setMetaTokenContract(meta.address);
        await musd.setMetaPriceOracleContract(metaOracle.address);

        await musd.endSetupPhase();

        //deposit+mint large amount of mUSD
        let mintQty = new BN(1000000); //$1m in mUSD

        let qty1 = (mintQty
            .mul(new BN(10).pow(await token1.decimals()))
            .mul(new BN(weight1)))
            .div(MAX_WEIGHT);
        let qty2 = (mintQty
            .mul(new BN(10).pow(await token2.decimals()))
            .mul(new BN(weight2)))
            .div(MAX_WEIGHT);
        let qty3 = (mintQty
            .mul(new BN(10).pow(await token3.decimals()))
            .mul(new BN(weight3)))
            .div(MAX_WEIGHT);
        let qty4 = (mintQty
            .mul(new BN(10).pow(await token4.decimals()))
            .mul(new BN(weight4)))
            .div(MAX_WEIGHT);
        let qty5 = (mintQty
            .mul(new BN(10).pow(await token5.decimals()))
            .mul(new BN(weight5)))
            .div(MAX_WEIGHT);

        await token1.approve(musd.address, qty1);
        await token2.approve(musd.address, qty2);
        await token3.approve(musd.address, qty3);
        await token4.approve(musd.address, qty4);
        await token5.approve(musd.address, qty5);

        let tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
        let quantities = [qty1, qty2, qty3, qty4, qty5];

        //scale mintQty with decimal places
        mintQty = mintQty.mul(
            new BN(10).pow(await musd.decimals())
        );

        await musd.depositTokensThenMint(tokenAddresses, quantities, mintQty);

    });

    describe('Test redeem function', function () {
        it('should not allow redemption of a zero quantity', async function () {

            await shouldFail.reverting(musd.redeem(new BN(0)));

        });
        it('should not allow redemption with insufficient mUSD balance', async function () {

            //first redeem all possible
            await musd.redeem(
                new BN(1000000).mul(
                    new BN(10).pow(await musd.decimals())
                )
            );

            //then try redeeming
            await shouldFail.reverting(musd.redeem(new BN(1)));

            //then put balance back
            let mintQty = new BN(1000000); //$1m in mUSD
            let qty1 = (mintQty
                .mul(new BN(10).pow(await token1.decimals()))
                .mul(new BN(weight1)))
                .div(MAX_WEIGHT);
            let qty2 = (mintQty
                .mul(new BN(10).pow(await token2.decimals()))
                .mul(new BN(weight2)))
                .div(MAX_WEIGHT);
            let qty3 = (mintQty
                .mul(new BN(10).pow(await token3.decimals()))
                .mul(new BN(weight3)))
                .div(MAX_WEIGHT);
            let qty4 = (mintQty
                .mul(new BN(10).pow(await token4.decimals()))
                .mul(new BN(weight4)))
                .div(MAX_WEIGHT);
            let qty5 = (mintQty
                .mul(new BN(10).pow(await token5.decimals()))
                .mul(new BN(weight5)))
                .div(MAX_WEIGHT);
            await token1.approve(musd.address, qty1);
            await token2.approve(musd.address, qty2);
            await token3.approve(musd.address, qty3);
            await token4.approve(musd.address, qty4);
            await token5.approve(musd.address, qty5);
            let tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            let quantities = [qty1, qty2, qty3, qty4, qty5];
            //scale mintQty with decimal places
            mintQty = mintQty.mul(
                new BN(10).pow(await musd.decimals())
            );
            await musd.depositTokensThenMint(tokenAddresses, quantities, mintQty);

        });
        it('should allow valid redemption', async function () {

            await musd.redeem(new BN(1));

        });
        it('should correctly decrease mUSD balance after valid redemption', async function () {

            let initialBalance = await musd.balanceOf(accountOne);
            await musd.redeem(new BN(1));
            (await musd.balanceOf(accountOne)).should.be.bignumber.equal(initialBalance.sub(new BN(1)));

        });
        it('should correctly increase token balances after valid redemption', async function () {

            let initial1 = await musd.userTokenBalances(accountOne, token1.address);
            let initial2 = await musd.userTokenBalances(accountOne, token2.address);
            let initial3 = await musd.userTokenBalances(accountOne, token3.address);
            let initial4 = await musd.userTokenBalances(accountOne, token4.address);
            let initial5 = await musd.userTokenBalances(accountOne, token5.address);

            let redeemQty = new BN(1);

            // basket quantities for 1 mUSD:
            // 0.5 standard units of token 1 = 0.5 * 10^(0 decimal places) = 0.5 units
            // 0.4 standard units of token 2 = 0.4 * 10^(1 decimal place) = 4 units
            // 0.09 standard units of token 3 = 0.09 * 10^(4 decimal places) = 900 units
            // 0.0099 standard units of token 4 = 0.0099 * 10^(8 decimal places) = 990000 units
            // 0.0001 standard units of token 5 = 0.0001 * 10^(18 decimal places) = 100000000000000 units
            let qty1 = (redeemQty
                .mul(new BN(10).pow(await token1.decimals()))
                .mul(new BN(weight1)))
                .div(MAX_WEIGHT);
            let qty2 = (redeemQty
                .mul(new BN(10).pow(await token2.decimals()))
                .mul(new BN(weight2)))
                .div(MAX_WEIGHT);
            let qty3 = (redeemQty
                .mul(new BN(10).pow(await token3.decimals()))
                .mul(new BN(weight3)))
                .div(MAX_WEIGHT);
            let qty4 = (redeemQty
                .mul(new BN(10).pow(await token4.decimals()))
                .mul(new BN(weight4)))
                .div(MAX_WEIGHT);
            let qty5 = (redeemQty
                .mul(new BN(10).pow(await token5.decimals()))
                .mul(new BN(weight5)))
                .div(MAX_WEIGHT);

            musd.redeem(redeemQty.mul(
                new BN(10).pow(await musd.decimals())
                )
            );

            //then check token balances
            (await musd.userTokenBalances(accountOne, token1.address)).should.be.bignumber.equal(initial1.add(qty1));
            (await musd.userTokenBalances(accountOne, token2.address)).should.be.bignumber.equal(initial2.add(qty2));
            (await musd.userTokenBalances(accountOne, token3.address)).should.be.bignumber.equal(initial3.add(qty3));
            (await musd.userTokenBalances(accountOne, token4.address)).should.be.bignumber.equal(initial4.add(qty4));
            (await musd.userTokenBalances(accountOne, token5.address)).should.be.bignumber.equal(initial5.add(qty5));

        });
        it('should correctly burn MTA balance after valid redemption', async function () {

            let initialBalance = await meta.balanceOf(accountOne);

            //set redemption fee
            const metaFee = new BN(5).mul(new BN(10).pow(new BN(15))); //0.5%
            await musd.setRedemptionFee(metaFee);

            //redeem
            let redeemQty = new BN(1);
            await musd.redeem(redeemQty);

            //then check MTA balance
            (await meta.balanceOf(accountOne)).should.be.bignumber.equal(
                initialBalance.sub(
                    redeemQty
                        .mul(metaFee)
                        .div(new BN(10).pow(await musd.decimals()))
                        .mul(new BN(100))
                        .div(await metaOracle.getPrice())
                )
            );

            //set redemption fee back to zero
            await musd.setRedemptionFee(new BN(0));

        });
    });

    describe('Test redeemThenWithdrawTokens function', function () {
        it('should not allow valid redemption then invalid withdrawal of tokens', async function () {

            let redeemQty = new BN(12).mul(
                new BN(10).pow(await musd.decimals())
            );
            //$12 in mUSD (will have sufficient balances)

            let qty1 = new BN(1);
            let qty2 = new BN(1);
            let qty3 = new BN(0); //invalid withdrawal quantity of 0
            let qty4 = new BN(1);
            let qty5 = new BN(1);

            let tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            let quantities = [qty1, qty2, qty3, qty4, qty5];

            await shouldFail.reverting(musd.redeemThenWithdrawTokens(redeemQty, tokenAddresses, quantities));

        });
        it('should not allow invalid redemption then withdrawal of tokens', async function () {

            let redeemQty = new BN(0); //invalid redeem quantity

            //valid withdraw quantities
            let qty1 = new BN(1);
            let qty2 = new BN(1);
            let qty3 = new BN(1);
            let qty4 = new BN(1);
            let qty5 = new BN(1);

            let tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            let quantities = [qty1, qty2, qty3, qty4, qty5];

            await shouldFail.reverting(musd.redeemThenWithdrawTokens(redeemQty, tokenAddresses, quantities));

        });
        it('should allow valid redemption then valid withdrawal of tokens', async function () {

            let redeemQty = new BN(100);

            // basket quantities for 1 mUSD:
            // 0.5 standard units of token 1 = 0.5 * 10^(0 decimal places) = 0.5 units
            // 0.4 standard units of token 2 = 0.4 * 10^(1 decimal place) = 4 units
            // 0.09 standard units of token 3 = 0.09 * 10^(4 decimal places) = 900 units
            // 0.0099 standard units of token 4 = 0.0099 * 10^(8 decimal places) = 990000 units
            // 0.0001 standard units of token 5 = 0.0001 * 10^(18 decimal places) = 100000000000000 units
            let qty1 = (redeemQty
                .mul(new BN(10).pow(await token1.decimals()))
                .mul(new BN(weight1)))
                .div(MAX_WEIGHT);
            let qty2 = (redeemQty
                .mul(new BN(10).pow(await token2.decimals()))
                .mul(new BN(weight2)))
                .div(MAX_WEIGHT);
            let qty3 = (redeemQty
                .mul(new BN(10).pow(await token3.decimals()))
                .mul(new BN(weight3)))
                .div(MAX_WEIGHT);
            let qty4 = (redeemQty
                .mul(new BN(10).pow(await token4.decimals()))
                .mul(new BN(weight4)))
                .div(MAX_WEIGHT);
            let qty5 = (redeemQty
                .mul(new BN(10).pow(await token5.decimals()))
                .mul(new BN(weight5)))
                .div(MAX_WEIGHT);

            let tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            let quantities = [qty1, qty2, qty3, qty4, qty5];

            redeemQty = redeemQty.mul(
                new BN(10).pow(await musd.decimals())
            );

            await musd.redeemThenWithdrawTokens(redeemQty, tokenAddresses, quantities);

        });
        it('should correctly update (token, MTA, mUSD) balances after valid withdrawal of tokens followed by redemption', async function () {

            let initial1 = await musd.userTokenBalances(accountOne, token1.address);
            let initial2 = await musd.userTokenBalances(accountOne, token2.address);
            let initial3 = await musd.userTokenBalances(accountOne, token3.address);
            let initial4 = await musd.userTokenBalances(accountOne, token4.address);
            let initial5 = await musd.userTokenBalances(accountOne, token5.address);
            let initialMetaBalance = await meta.balanceOf(accountOne);
            let initialmUSDBalance = await musd.balanceOf(accountOne);

            let redeemQty = new BN(200);

            let qty1 = (redeemQty
                .mul(new BN(10).pow(await token1.decimals()))
                .mul(new BN(weight1)))
                .div(MAX_WEIGHT);
            let qty2 = (redeemQty
                .mul(new BN(10).pow(await token2.decimals()))
                .mul(new BN(weight2)))
                .div(MAX_WEIGHT);
            let qty3 = (redeemQty
                .mul(new BN(10).pow(await token3.decimals()))
                .mul(new BN(weight3)))
                .div(MAX_WEIGHT);
            let qty4 = (redeemQty
                .mul(new BN(10).pow(await token4.decimals()))
                .mul(new BN(weight4)))
                .div(MAX_WEIGHT);
            let qty5 = (redeemQty
                .mul(new BN(10).pow(await token5.decimals()))
                .mul(new BN(weight5)))
                .div(MAX_WEIGHT);

            let tokenAddresses = [token1.address, token2.address, token3.address, token4.address, token5.address];
            let quantities = [qty1, qty2, qty3, qty4, qty5];

            //set redemption fee
            const metaFee = new BN(35).mul(new BN(10).pow(new BN(15))); //3.5%
            await musd.setRedemptionFee(metaFee);
            
            redeemQty = redeemQty.mul(
                new BN(10).pow(await musd.decimals())
            );

            //redeem+withdraw
            await musd.redeemThenWithdrawTokens(redeemQty, tokenAddresses, quantities);
            
            //then check MTA balance
            (await meta.balanceOf(accountOne)).should.be.bignumber.equal(
                initialMetaBalance.sub(
                    redeemQty
                        .mul(metaFee)
                        .div(new BN(10).pow(await musd.decimals()))
                        .mul(new BN(100))
                        .div(await metaOracle.getPrice())
                )
            );

            //then check mUSD balance
            (await musd.balanceOf(accountOne)).should.be.bignumber.equal(initialmUSDBalance.sub(redeemQty));

            //then check token balances
            (await musd.userTokenBalances(accountOne, token1.address)).should.be.bignumber.equal(initial1);
            (await musd.userTokenBalances(accountOne, token2.address)).should.be.bignumber.equal(initial2);
            (await musd.userTokenBalances(accountOne, token3.address)).should.be.bignumber.equal(initial3);
            (await musd.userTokenBalances(accountOne, token4.address)).should.be.bignumber.equal(initial4);
            (await musd.userTokenBalances(accountOne, token5.address)).should.be.bignumber.equal(initial5);

            //set redemption fee back to zero
            await musd.setRedemptionFee(new BN(0));

        });
    });

});
