/* eslint-disable no-console */
import "ts-node/register"
import "tsconfig-paths/register"

import { btcBassets, startingCap, capFactor, config, mBtcName, mBtcSymbol, DeployedBasset } from "@utils/btcConstants"
import { DEAD_ADDRESS, ZERO_ADDRESS } from "@utils/constants"
import { Signer } from "ethers"
import { task } from "hardhat/config"
import { formatEther } from "ethers/lib/utils"
import {
    SavingsContract,
    Masset,
    Masset__factory,
    InvariantValidator__factory,
    AssetProxy__factory,
    MockERC20,
    MockERC20__factory,
    MockInitializableToken__factory,
    SavingsContract__factory,
    BoostedSavingsVault__factory,
    BoostedSavingsVault,
    ERC20__factory,
    SaveWrapper__factory,
    RenWrapper__factory,
} from "types/generated"
import { simpleToExactAmount, BN } from "@utils/math"

interface CommonAddresses {
    mta: string
    staking: string
    nexus: string
    proxyAdmin: string
    rewardsDistributor: string
    uniswap: string
    poker: string
    renGatewayRegistry: string
}

const deployBasset = async (sender: Signer, name: string, symbol: string, decimals = 18, initialMint = 500000): Promise<MockERC20> => {
    // Implementation
    const impl = await new MockInitializableToken__factory(sender).deploy()
    await impl.deployTransaction.wait()

    // Initialization Data
    const data = impl.interface.encodeFunctionData("initialize", [name, symbol, decimals, await sender.getAddress(), initialMint])
    // Proxy
    const proxy = await new AssetProxy__factory(sender).deploy(impl.address, DEAD_ADDRESS, data)
    const receipt = await proxy.deployTransaction.wait()

    console.log(`Deployed ${name} (${symbol}) to address ${proxy.address}. gas used ${receipt.gasUsed}`)

    return new MockERC20__factory(sender).attach(proxy.address)
}

const deployMasset = async (sender: Signer, addresses: CommonAddresses, ethers, bAssetContracts: DeployedBasset[]): Promise<Masset> => {
    // Invariant Validator
    console.log(`Deploying Invariant Validator with startingCap ${startingCap.toString()} and capfactor ${capFactor.toString()}`)
    const forgeVal = await new InvariantValidator__factory(sender).deploy(startingCap, capFactor)
    const receiptForgeVal = await forgeVal.deployTransaction.wait()
    console.log(`Deployed Invariant Validator to ${forgeVal.address}. gas used ${receiptForgeVal.gasUsed}`)

    // External linked library
    const Manager = await ethers.getContractFactory("Manager")
    const managerLib = await Manager.deploy()
    const receiptManager = await managerLib.deployTransaction.wait()
    console.log(`Deployed Manager library to ${managerLib.address}. gas used ${receiptManager.gasUsed}`)

    const linkedAddress = {
        __$1a38b0db2bd175b310a9a3f8697d44eb75$__: managerLib.address,
    }
    // Implementation
    const massetFactory = new Masset__factory(linkedAddress, sender)
    const size = massetFactory.bytecode.length / 2 / 1000
    if (size > 24.576) {
        console.error(`Masset size is ${size} kb: ${size - 24.576} kb too big`)
    } else {
        console.log(`Masset = ${size} kb`)
    }
    console.log(`Deploying Masset with ManagerAddr: ${managerLib.address} and nexus ${addresses.nexus}`)
    const impl = await massetFactory.deploy(addresses.nexus)
    const receiptImpl = await impl.deployTransaction.wait()
    console.log(`Deployed Masset to ${impl.address}. gas used ${receiptImpl.gasUsed}`)

    // Initialization Data
    console.log(
        `Initializing Masset with: ${mBtcName}, ${mBtcSymbol}, ${forgeVal.address}, [${bAssetContracts.map(
            // eslint-disable-next-line
            (b) => "{" + b.contract.address + ", " + b.integrator + ", " + b.txFee + ", " + 0 + "}",
        )} ] , ${config.a.toString()}, ${config.limits.min.toString()}, ${config.limits.max.toString()}`,
    )
    const data = impl.interface.encodeFunctionData("initialize", [
        mBtcName,
        mBtcSymbol,
        forgeVal.address,
        bAssetContracts.map((b) => ({
            addr: b.contract.address,
            integrator: b.integrator,
            hasTxFee: b.txFee,
            status: 0,
        })),
        config,
    ])
    // Proxy
    console.log(`Deploying mBTC proxy with impl: ${impl.address} and admin ${addresses.proxyAdmin}`)
    const mBtcProxy = await new AssetProxy__factory(sender).deploy(impl.address, addresses.proxyAdmin, data)
    const receiptProxy = await mBtcProxy.deployTransaction.wait()

    console.log(`Deployed mBTC to address ${mBtcProxy.address}. gas used ${receiptProxy.gasUsed}`)

    if (addresses.renGatewayRegistry !== DEAD_ADDRESS) {
        const gateway = await new RenWrapper__factory(sender).deploy(mBtcProxy.address, addresses.renGatewayRegistry)
        const receiptGateway = await gateway.deployTransaction.wait()
        console.log(`Deployed Ren Gateway wrapper to address ${gateway.address}. gas used ${receiptGateway.gasUsed}`)
    }

    // Create a Masset contract pointing to the deployed proxy contract
    return new Masset__factory(linkedAddress, sender).attach(mBtcProxy.address)
}

const mint = async (sender: Signer, bAssets: DeployedBasset[], mBTC: Masset) => {
    // Mint 3/5 of starting cap
    const scaledTestQty = startingCap.div(5)

    // Approve spending
    // eslint-disable-next-line
    for (const bAsset of bAssets) {
        // eslint-disable-next-line
        const tx = await bAsset.contract.approve(mBTC.address, scaledTestQty)
        // eslint-disable-next-line
        const receiptApprove = await tx.wait()
        console.log(
            // eslint-disable-next-line
            `Approved mBTC to transfer ${formatEther(scaledTestQty)} ${bAsset.symbol} from ${await sender.getAddress()}. gas used ${
                receiptApprove.gasUsed
            }`,
        )
    }

    // Mint
    const tx = await mBTC.mintMulti(
        bAssets.map((b) => b.contract.address),
        bAssets.map(() => scaledTestQty),
        1,
        await sender.getAddress(),
    )
    const receiptMint = await tx.wait()

    // Log minted amount
    const mAssetAmount = formatEther(await mBTC.totalSupply())
    console.log(`Minted ${mAssetAmount} mBTC from ${formatEther(scaledTestQty)} BTC for each bAsset. gas used ${receiptMint.gasUsed}`)
}

interface SaveContracts {
    savingContract: SavingsContract
    savingsVault: BoostedSavingsVault
}

const deploySave = async (
    sender: Signer,
    addresses: CommonAddresses,
    mBTC: Masset,
    bAssets: Array<string>,
    deployVault = true,
): Promise<SaveContracts> => {
    // Save impl
    console.log(`Deploying Savings Contract nexus: ${addresses.nexus} and underlying ${mBTC.address}`)
    const sImpl = await new SavingsContract__factory(sender).deploy(addresses.nexus, mBTC.address)
    const receiptSaving = await sImpl.deployTransaction.wait()
    console.log(`Deployed Savings contract to ${sImpl.address}. gas used ${receiptSaving.gasUsed}`)

    // Data
    const sData = sImpl.interface.encodeFunctionData("initialize", [addresses.poker, "Interest bearing mStable BTC", "imBTC"])
    // Proxy
    console.log(`Deploying Savings Contract proxy, impl: ${sImpl.address}, admin: ${addresses.proxyAdmin}`)
    const sProxy = await new AssetProxy__factory(sender).deploy(sImpl.address, addresses.proxyAdmin, sData)
    const receiptProxy = await sProxy.deployTransaction.wait()
    const savingContract = await new SavingsContract__factory(sender).attach(sProxy.address)
    console.log(`Deployed Saving Proxy to ${sProxy.address}. gas used ${receiptProxy.gasUsed}`)

    // Vault impl
    if (deployVault) {
        const vImpl = await new BoostedSavingsVault__factory(sender).deploy(
            addresses.nexus,
            savingContract.address,
            addresses.staking,
            simpleToExactAmount(3000, 18),
            addresses.mta,
        )
        const receiptVaultImpl = await vImpl.deployTransaction.wait()
        console.log(`Deployed Vault Impl to ${sProxy.address}. gas used ${receiptVaultImpl.gasUsed}`)

        // Data
        const vData = vImpl.interface.encodeFunctionData("initialize", [addresses.rewardsDistributor])
        // Proxy
        const vProxy = await new AssetProxy__factory(sender).deploy(vImpl.address, addresses.proxyAdmin, vData)
        const receiptVaultProxy = await vProxy.deployTransaction.wait()
        const savingsVault = await new BoostedSavingsVault__factory(sender).attach(vProxy.address)
        console.log(`Deployed Vault Proxy to ${vProxy.address}. gas used ${receiptVaultProxy.gasUsed}`)

        // SaveWrapper
        const wrapper = await new SaveWrapper__factory(sender).deploy(
            savingContract.address,
            savingsVault.address,
            mBTC.address,
            bAssets,
            addresses.uniswap,
        )
        const receiptSavingWrapper = await wrapper.deployTransaction.wait()
        console.log(`Deployed Savings Wrapper to address ${wrapper.address}. gas used ${receiptSavingWrapper.gasUsed}`)

        return { savingContract, savingsVault }
    }
    // SaveWrapper
    console.log(`Deploying Wrapper...`)
    const wrapper = await new SaveWrapper__factory(sender).deploy(
        savingContract.address,
        DEAD_ADDRESS,
        mBTC.address,
        bAssets,
        addresses.uniswap,
    )
    const receiptSavingWrapper = await wrapper.deployTransaction.wait()
    console.log(`Deployed Savings Wrapper to address ${wrapper.address}. gas used ${receiptSavingWrapper.gasUsed}`)

    return { savingContract, savingsVault: null }
}

const depositToVault = async (sender: Signer, mBTC: Masset, save: SaveContracts): Promise<void> => {
    // Mint imBTC
    const deposit = startingCap.div(BN.from(3))
    let tx = await mBTC.approve(save.savingContract.address, deposit)
    await tx.wait()
    tx = await save.savingContract.preDeposit(deposit, await sender.getAddress())
    await tx.wait()
    const balance = await save.savingContract.balanceOf(await sender.getAddress())

    // Deposit to vault
    tx = await save.savingContract.approve(save.savingsVault.address, balance)
    await tx.wait()
    tx = await save.savingsVault["stake(uint256)"](balance)
    tx.wait()

    console.log(`Minted ${formatEther(balance)} imBTC from ${formatEther(deposit)} mBTC and deposited to vault`)
}

task("deployFeeder", "Deploys a feeder pool").setAction(async (_, hre) => {
    const { ethers, network } = hre
    const [deployer] = await ethers.getSigners()

    const addresses = {
        mta: DEAD_ADDRESS,
        staking: (await new MockERC20__factory(deployer).deploy("Stake", "ST8", 18, DEAD_ADDRESS, 1)).address,
        nexus: DEAD_ADDRESS,
        proxyAdmin: DEAD_ADDRESS,
        rewardsDistributor: DEAD_ADDRESS,
        uniswap: DEAD_ADDRESS,
        poker: DEAD_ADDRESS,
        renGatewayRegistry: DEAD_ADDRESS,
    }

    // 1. Deploy fAsset
    const fAsset: MockERC20 = await deployBasset(deployer, "Feeder pool Asset", "fAST", 18, 1000000)
    const mAsset: Masset = await deployBasset(deployer, "Feeder pool Asset", "fAST", 18, 1000000)

    // 2. Deploy mBTC
    const mBTC = await deployMasset(deployer, addresses, ethers, bAssets)

    // 3. Mint initial supply
    await mint(deployer, bAssets, mBTC)

    // TODO
    // - Deploy vault & fund
})

module.exports = {}
