
/*
 * Based on compound-finance/open-oracle
 *
 * https://github.com/compound-finance/open-oracle
 */


pragma solidity ^0.5.12;
//pragma experimental ABIEncoderV2;

import "../../oracle-hub/data/OracleHubData.sol";

/**
 * @title Mock Open Oracle Price Data Contract
 * @notice Values stored in this contract should represent a USD price with 6 decimals precision
 * @author Stability Labs
 */
contract MockOpenOraclePriceData is OracleHubData {

    uint8 constant DECIMALS = 6;
    uint64 constant UNIT = 1e6;
    Config DEFAULT_CONFIG = Config(1e6, 1e4, 10);

    /**
     * @notice The event emitted when a source writes to its storage
     */
    //event Write(address indexed source, string key, uint64 timestamp, uint64 value);

    /**
     * @notice The fundamental unit of storage for a reporter source
     */
    struct Datum {
        uint64 timestamp;
        uint64 value;
    }

    struct Config {
        uint64 base;
        uint64 variance;
        uint64 interval;
    }

    /**
     * @notice The most recent authenticated data from all sources
     * @dev This is private because dynamic mapping keys preclude auto-generated getters.
     */
    mapping(address => mapping(string => Datum)) private data;
    mapping(string => Config) private configs;

    /**
     * @notice Write a bunch of signed datum to the authenticated storage mapping
     * @param message The payload containing the timestamp, and (key, value) pairs
     * @param signature The cryptographic signature of the message payload, authorizing the source to write
     * @return The keys that were written
     */
    function put(bytes calldata message, bytes calldata signature) external returns (string memory) {
        // Recover the source address
        address source = source(message, signature);

        // Decode the message and check the kind
        (string memory kind, uint64 timestamp, string memory key, uint64 value) = abi.decode(message, (string, uint64, string, uint64));
        require(keccak256(abi.encodePacked(kind)) == keccak256(abi.encodePacked("prices")), "Kind of data must be 'prices'");

        // Only update if newer than stored, according to source
        Datum storage prior = data[source][key];
        if (prior.timestamp < timestamp) {
            data[source][key] = Datum(timestamp, value);
            //emit Write(source, key, timestamp, value);
        }

        return key;
    }

    function getConfigOrDefault(string memory key) internal view returns (Config storage) {
        Config storage config = configs[key];
        if (configs[key].base == 0) {
            return DEFAULT_CONFIG;
        }
        return config;
    }

    function getMockTimestamp(Config storage config) internal view returns(uint64) {
        /* solium-disable-next-line */
        return uint64((now / uint256(config.interval)) * uint256(config.interval));
    }

    function getMockValue(address source, uint64 time, Config storage config) internal view returns (uint64) {
        // use source and time to generate psudo-random bucket
        uint160 bucket = uint160(source) ^ uint160(time);

        // TODO(ryan): how does this keccak256(abi.encode()) work?
        // get random value for bucket
        int128 bucketValue = int128(int256(keccak256(abi.encode(bucket))));

        // truncate bucketValue to be -UNIT < bucket_value < UNIT
        bucketValue -= (bucketValue / int128(UNIT)) * int128(UNIT);

        // calcuate divergence
        int128 divergence = bucketValue * int128(config.variance) / int128(UNIT);

        // apply divergence
        return uint64(int256(config.base) + divergence);
    }

    function configure(string calldata key, uint64 base, uint64 variance, uint64 interval) external {
        require(base > 0, "Base must be greater than zero");
        require(variance < base, "Variance must be less than base");
        require(interval > 0, "Interval must be greater than zero");

        configs[key] = Config(base, variance, interval);
    }

    /**
     * @notice Read a single key from an authenticated source
     * @param source The verifiable author of the data
     * @param key The selector for the value to return
     * @return The claimed Unix timestamp for the data and the price value (defaults to (0, 0))
     */
    function get(address source, string calldata key) external view returns (uint64, uint64) {
        Config storage config = getConfigOrDefault(key);
        uint64 time = getMockTimestamp(config);
        return (time, getMockValue(source, time, config));
        //Datum storage datum = data[source][key];
        //return (datum.timestamp, datum.value);
    }

    /**
     * @notice Read only the value for a single key from an authenticated source
     * @param source The verifiable author of the data
     * @param key The selector for the value to return
     * @return The price value (defaults to 0)
     */
    function getPrice(address source, string calldata key) external view returns (uint64) {
        return data[source][key].value;
    }
}
